# LeetCode 热题 100

### 一、哈希表

##### 1. 两数之和（1）

![image-20240411145506422](./hot100/image-20240411145506422.png)

![image-20240411145556999](./hot100/image-20240411145556999.png)

##### 2. 字母异位词（49）

![image-20240411145722760](./hot100/image-20240411145722760.png)

![image-20240411145834174](./hot100/image-20240411145834174.png)

##### 3. 最长连续序列（128）

![image-20240411150227500](./hot100/image-20240411150227500.png)

![image-20240411152315721](./hot100/image-20240411152315721.png)

### 二、双指针

##### 4. 移动零（283）

![image-20240412213054978](./hot100/image-20240412213054978.png)

![image-20240412213352144](./hot100/image-20240412213352144.png)

##### 5. 盛水最多的容器（11）

![image-20240412213627930](./hot100/image-20240412213627930.png)

![image-20240412214604625](./hot100/image-20240412214604625.png)

##### 6. 三数之和（15）

![image-20240412214844994](./hot100/image-20240412214844994.png)

![image-20240412222912790](./hot100/image-20240412222912790.png)

##### 7. 接雨水（42）

![image-20240413092435242](./hot100/image-20240413092435242.png)

![image-20240413095121792](./hot100/image-20240413095121792.png)

### 三、滑动窗口

##### 8. 无重复字符的最长子串（3）

![image-20240414101004121](./hot100/image-20240414101004121.png)

![image-20240414103031344](./hot100/image-20240414103031344.png)

##### 9. 找到字符串中所有字母异位词（438）

![image-20240416215002459](./hot100/image-20240416215002459.png)

![image-20240416220618087](./hot100/image-20240416220618087.png)

### 四、子串

##### 10. 和为K的子数组（560）

![image-20240416220723481](./hot100/image-20240416220723481.png)

![image-20240416224424748](./hot100/image-20240416224424748.png)

##### 11.  滑动窗口最大值（239）

![image-20240417224628015](./hot100/image-20240417224628015.png)

![image-20240417232622067](./hot100/image-20240417232622067.png)

##### 12. 最小覆盖子串（76）

![image-20240418132540768](./hot100/image-20240418132540768.png)

![image-20240418140516756](./hot100/image-20240418140516756.png)

### 五、普通数组

##### 13. 最大子数组和（53）

![image-20240418141251656](./hot100/image-20240418141251656.png)

![image-20240418141644728](./hot100/image-20240418141644728.png)

##### 14. 合并区间（56）

![image-20240418141744176](./hot100/image-20240418141744176.png)

![image-20240418142003152](./hot100/image-20240418142003152.png)

##### 15. 轮转数组（189）

![image-20240418142111482](./hot100/image-20240418142111482.png)

![image-20240418143247190](./hot100/image-20240418143247190.png)

##### 16. 除自身以外数组的乘积

![image-20240418143403806](./hot100/image-20240418143403806.png)

![image-20240418145248200](./hot100/image-20240418145248200.png)

##### 17. 缺失的第一个正数（41）

![image-20240418151426146](./hot100/image-20240418151426146.png)

![image-20240418153026290](./hot100/image-20240418153026290.png)

### 六、矩阵

##### 18. 矩阵置零（73）

![image-20240419133804139](./hot100/image-20240419133804139.png)

![image-20240419143645935](./hot100/image-20240419143645935.png)

##### 19. 螺旋矩阵（54）

![image-20240425134742069](./hot100/image-20240425134742069.png)

![image-20240425140609092](./hot100/image-20240425140609092.png)

##### 20. 旋转图像（48）

![image-20240425140739579](./hot100/image-20240425140739579.png)

![image-20240425153039384](./hot100/image-20240425153039384.png)

##### 21. 搜索二维矩阵Ⅱ（240）

![image-20240425155113561](./hot100/image-20240425155113561.png)

![image-20240425194533916](./hot100/image-20240425194533916.png)

### 七、链表

##### 22. 相交链表（160）

![image-20240426141603173](./hot100/image-20240426141603173.png)

![image-20240426141636471](./hot100/image-20240426141636471.png)

##### 23. 反转链表（206）

![image-20240426142118823](./hot100/image-20240426142118823.png)

![image-20240426144131165](./hot100/image-20240426144131165.png)

##### 24. 回文链表（234）

![image-20240426144217298](./hot100/image-20240426144217298.png)

![image-20240426144811789](./hot100/image-20240426144811789.png)

##### 25. 环形链表（141）

![image-20240426144935957](./hot100/image-20240426144935957.png)

![image-20240426150241722](./hot100/image-20240426150241722.png)

##### 26. 环形链表Ⅱ（142）

![image-20240427102527535](./hot100/image-20240427102527535.png)

![image-20240427102506277](./hot100/image-20240427102506277.png)

##### 27. 合并两个有序链表（21）

![image-20240427103932755](./hot100/image-20240427103932755.png)

![image-20240427103918123](./hot100/image-20240427103918123.png)

##### 28. 两数相加（2）

![image-20240428133525192](./hot100/image-20240428133525192.png)

![image-20240428134308296](./hot100/image-20240428134308296.png)

##### 29. 删除链表的倒数第N个结点（19）

![image-20240428142243197](./hot100/image-20240428142243197.png)

![image-20240428143104122](./hot100/image-20240428143104122.png)

##### 30. 两两交换链表中的节点（24）

![image-20240428143213644](./hot100/image-20240428143213644.png)

![image-20240428150013587](./hot100/image-20240428150013587.png)

##### 31. K个一组翻转链表（25）

![image-20240428150335097](./hot100/image-20240428150335097.png)

![image-20240428155135495](./hot100/image-20240428155135495.png)

##### 32. 随机链表的复制（138）

![image-20240501112123727](./hot100/image-20240501112123727.png)

![image-20240501112202003](./hot100/image-20240501112202003.png)

##### 33. 排序链表（148）

![image-20240501112418113](./hot100/image-20240501112418113.png)

![image-20240502101642462](./hot100/image-20240502101642462.png)

##### 34. 合并K个升序链表（23）

![image-20240502105636908](./hot100/image-20240502105636908.png)

![image-20240502105601643](./hot100/image-20240502105601643.png)

##### 35. LRU缓存

### 八、二叉树

##### 36. 二叉树的中序遍历（94）

![image-20240503101103106](./hot100/image-20240503101103106.png)

![image-20240503101834065](./hot100/image-20240503101834065.png)

##### 37. 二叉树的最大深度（104）

![image-20240503102957926](./hot100/image-20240503102957926.png)

![image-20240503103022245](./hot100/image-20240503103022245.png)

##### 38. 翻转二叉树（226）

![image-20240503103542883](./hot100/image-20240503103542883.png)

![image-20240503103637608](./hot100/image-20240503103637608.png)

##### 39. 对称二叉树（101）

![image-20240503105147620](./hot100/image-20240503105147620.png)

![image-20240503105123410](./hot100/image-20240503105123410.png)

##### 40. 二叉树的直径（543）

![image-20240503111007886](./hot100/image-20240503111007886.png)

![image-20240503110954679](./hot100/image-20240503110954679.png)

##### 41. 二叉树的层序遍历（102）

![image-20240506181202573](./hot100/image-20240506181202573.png)

![image-20240506181451322](./hot100/image-20240506181451322.png)

##### 42. 将有序数组转化为二叉搜索树（108）

![image-20240506181735775](./hot100/image-20240506181735775.png)

![image-20240506181834771](./hot100/image-20240506181834771.png)

##### 43. 验证二叉搜索树（98）

![image-20240506182022671](./hot100/image-20240506182022671.png)

![image-20240506182226144](./hot100/image-20240506182226144.png)

##### 44. 二叉搜索树中的第K小的元素

![image-20240506182355916](./hot100/image-20240506182355916.png)

![image-20240506182454350](./hot100/image-20240506182454350.png)

##### 45. 二叉树的右视图（199）

![image-20240506182548134](./hot100/image-20240506182548134.png)

![image-20240506182651180](./hot100/image-20240506182651180.png)

##### 46. 二叉树展开为链表（114）

![image-20240508134516326](./hot100/image-20240508134516326.png)

![image-20240508134935512](./hot100/image-20240508134935512.png)

##### 47. 从前序与中序遍历序列构造二叉树（105）

![image-20240508134649702](./hot100/image-20240508134649702.png)

![image-20240508135541939](./hot100/image-20240508135541939.png)

##### 48. 路径总和Ⅲ（437）

![image-20240509142422567](./hot100/image-20240509142422567.png)

![image-20240509142314618](./hot100/image-20240509142314618.png)

##### 49. 二叉树的最近公共祖先（236）

![image-20240523134000330](./hot100/image-20240523134000330.png)

![image-20240523141251450](./hot100/image-20240523141251450.png)

第一种思路自己想的，第二种思路答案（pq只有三种情况，一pq分布在root左右返回root，二p=root，q在p的左右子树，三q=root，p在q的左右子树，代码需要理解一下）

##### 50. 二叉树中的最大路径和（124）

![image-20240714195633942](./hot100/image-20240714195633942.png)

![image-20240714200129804](./hot100/image-20240714200129804.png)

### 九、图论

##### 51. 岛屿数量（200）

![image-20240714200535073](./hot100/image-20240714200535073.png)

![image-20240714203319916](./hot100/image-20240714203319916.png)

##### 52. 腐烂的橘子（994）

![image-20240715161338843](./hot100/image-20240715161338843.png)

![image-20240715162015795](./hot100/image-20240715162015795.png)

##### 53. 课程表（207）

![image-20240715162145083](./hot100/image-20240715162145083.png)

![image-20240715162752203](./hot100/image-20240715162752203.png)

（自己写的太慢，主要思路是遇到1就递归，主要记拓扑排序的方法）

##### 54. 实现前缀树Trie（208）

![image-20240715163113430](./hot100/image-20240715163113430.png)

![image-20240715184740641](./hot100/image-20240715184740641.png)

### 十、回溯

##### 55. 全排列（46）

![image-20240715184932927](./hot100/image-20240715184932927.png)

![image-20240715185036879](./hot100/image-20240715185036879.png)

##### 56. 子集（78）

![image-20240715185124421](./hot100/image-20240715185124421.png)

![image-20240715185241500](./hot100/image-20240715185241500.png)

##### 57. 电话号码的数字组合（17）

![image-20240715185350126](./hot100/image-20240715185350126.png)

![image-20240715185558974](./hot100/image-20240715185558974.png)

##### 58. 组合总和（39）

![image-20240715185716242](./hot100/image-20240715185716242.png)

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        ans = []
        self.backtracking([], ans, target, 0, len(candidates), candidates)
        return ans
        
    def backtracking(self, path, ans, target, startIndex, length, candidates):
        if sum(path) > target: return
        if sum(path) == target:
            ans.append(path[:])
            return
        for i in range(startIndex, length):
            path.append(candidates[i])
            self.backtracking(path, ans, target, i, length, candidates)
            path.pop()
        return
```

##### 59. 括号生成（22）

![image-20240715190038773](./hot100/image-20240715190038773.png)

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        ans = []
        self.backtracking([], ans, n, 0, 0)
        return ans
    
    def backtracking(self, path, ans, n, left, right):
        if len(path) == n*2:
            ans.append(''.join(path))
            return
        # 左右相等，下一个只能左
        if left == right:
            path.append('(')
            self.backtracking(path, ans, n, left+1, right)
            path.pop()
        # 左大于右且左已满，下一个只能右
        elif left == n:
            path.append(')')
            self.backtracking(path, ans, n, left, right+1)
            path.pop()
        # 左大于右且左未满，下一个可左可右
        else:
            path.append('(')
            self.backtracking(path, ans, n, left+1, right)
            path.pop()
            path.append(')')
            self.backtracking(path, ans, n, left, right+1)
            path.pop()
        return
```

##### 60. 单词搜索（79）

![image-20240715190343061](./hot100/image-20240715190343061.png)

![image-20240715190406122](./hot100/image-20240715190406122.png)

```python
# class Solution:
#     def exist(self, board: List[List[str]], word: str) -> bool:
#         rows, cols = len(board), len(board[0])
#         for i in range(rows):
#             for j in range(cols):
#                 if board[i][j] == word[0]:
#                     visited = [[0 for _ in range(cols)] for _ in range(rows)]
#                     if self.backtracking('', word, visited, board, i, j, rows, cols): return True
#         return False
    

#     def backtracking(self, path, word, visited, board, i, j, rows, cols):
#         if i < 0 or j < 0 or i >= rows or j >= cols: return False
#         if len(path) < len(word) and board[i][j] == word[len(path)] and visited[i][j] == 0:
#             path += board[i][j]
#             if path == word: return True
#             visited[i][j] = 1
#             f1 = self.backtracking(path, word, visited, board, i+1, j, rows, cols)
#             f2 = self.backtracking(path, word, visited, board, i-1, j, rows, cols)
#             f3 = self.backtracking(path, word, visited, board, i, j+1, rows, cols)
#             f4 = self.backtracking(path, word, visited, board, i, j-1, rows, cols)
#             visited[i][j] = 0
#             path = path[:-1]
#             return f1 or f2 or f3 or f4
#         else:
#             return False


class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        def dfs(i, j, k):
            if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j] != word[k]: return False
            if k == len(word) - 1: return True
            # 直接等于空字符串，相当于visited==1已访问
            board[i][j] = ''
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
            board[i][j] = word[k]
            return res

        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(i, j, 0): return True
        return False
```

##### 61. 分割回文串（131）

![image-20240715190736605](./hot100/image-20240715190736605.png)

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        ans = []
        self.backtracking([], ans, 0, len(s), s)
        return ans
        
    def backtracking(self, path, ans, startIndex, length, s):
        if startIndex >= length:
            ans.append(path[:])
            return
        for i in range(startIndex+1, length+1):
            if s[startIndex: i] == s[startIndex: i][::-1]:
                path.append(s[startIndex: i])
                self.backtracking(path, ans, i, length, s)
                path.pop()
        return
```

##### 62. N皇后（51）

![image-20240715191050838](./hot100/image-20240715191050838.png)

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        cheeseBoard = ['.'*n for _ in range(n)]
        ans = []
        self.backtracking(cheeseBoard, 0, ans, n)
        return ans

    def backtracking(self, cheeseBoard, row, ans, n):
        if row == n:
            ans.append(cheeseBoard[:])
            return
        for i in range(n):
            if self.isValid(row, i, cheeseBoard, n):
                cheeseBoard[row] = cheeseBoard[row][:i] + 'Q' + cheeseBoard[row][i+1:]
                self.backtracking(cheeseBoard, row+1, ans, n)
                cheeseBoard[row] = cheeseBoard[row][:i] + '.' + cheeseBoard[row][i+1:]
        return
    
    def isValid(self, row, col, cheeseBoard, n):
        for i in range(row):
            if cheeseBoard[i][col] == 'Q': return False
        i, j = row - 1, col + 1
        while i >= 0 and j < n:
            if cheeseBoard[i][j] == 'Q': return False
            i -= 1
            j += 1
        i, j = row - 1, col - 1
        while i >= 0 and j >= 0:
            if cheeseBoard[i][j] == 'Q': return False
            i -= 1
            j -= 1
        return True
```

### 十一、二分查找

##### 63. 搜索插入位置（35）

![image-20240715191318026](./hot100/image-20240715191318026.png)

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target: return mid
            elif nums[mid] > target: right = mid - 1
            else: left = mid + 1
        return left
```

##### 64. 搜索二维矩阵（74）

![image-20240715191614365](./hot100/image-20240715191614365.png)

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        top, bottom = 0, len(matrix) - 1
        while top <= bottom:
            mid = (top + bottom) // 2
            if matrix[mid][0] > target: bottom = mid - 1
            else: top = mid + 1
        left, right = 0, len(matrix[0]) - 1
        while left <= right:
            mid = (left + right) // 2
            if matrix[bottom][mid] > target: right = mid - 1
            else: left = mid + 1
        return matrix[bottom][right] == target
```

##### 65. 在排序数组中查找元素的第一个和最后一个位置（34）

![image-20240715191749714](./hot100/image-20240715191749714.png)

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                ans_l, ans_r = mid, mid
                while ans_l > 0 and nums[ans_l-1] == nums[ans_l]: ans_l -= 1
                while ans_r < len(nums) - 1 and nums[ans_r] == nums[ans_r + 1]: ans_r += 1
                return [ans_l, ans_r]
            elif nums[mid] > target: right = mid - 1
            else: left = mid + 1
        return [-1, -1]
```

