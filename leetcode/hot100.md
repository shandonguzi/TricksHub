# LeetCode 热题 100

### 一、哈希表

##### 1. 两数之和（1）

![image-20240411145506422](./hot100/image-20240411145506422.png)

![image-20240411145556999](./hot100/image-20240411145556999.png)

##### 2. 字母异位词（49）

![image-20240411145722760](./hot100/image-20240411145722760.png)

![image-20240411145834174](./hot100/image-20240411145834174.png)

##### 3. 最长连续序列（128）

![image-20240411150227500](./hot100/image-20240411150227500.png)

![image-20240411152315721](./hot100/image-20240411152315721.png)

### 二、双指针

##### 4. 移动零（283）

![image-20240412213054978](./hot100/image-20240412213054978.png)

![image-20240412213352144](./hot100/image-20240412213352144.png)

##### 5. 盛水最多的容器（11）

![image-20240412213627930](./hot100/image-20240412213627930.png)

![image-20240412214604625](./hot100/image-20240412214604625.png)

##### 6. 三数之和（15）

![image-20240412214844994](./hot100/image-20240412214844994.png)

![image-20240412222912790](./hot100/image-20240412222912790.png)

##### 7. 接雨水（42）

![image-20240413092435242](./hot100/image-20240413092435242.png)

![image-20240413095121792](./hot100/image-20240413095121792.png)

### 三、滑动窗口

##### 8. 无重复字符的最长子串（3）

![image-20240414101004121](./hot100/image-20240414101004121.png)

![image-20240414103031344](./hot100/image-20240414103031344.png)

##### 9. 找到字符串中所有字母异位词（438）

![image-20240416215002459](./hot100/image-20240416215002459.png)

![image-20240416220618087](./hot100/image-20240416220618087.png)

### 四、子串

##### 10. 和为K的子数组（560）

![image-20240416220723481](./hot100/image-20240416220723481.png)

![image-20240416224424748](./hot100/image-20240416224424748.png)

##### 11.  滑动窗口最大值（239）

![image-20240417224628015](./hot100/image-20240417224628015.png)

![image-20240417232622067](./hot100/image-20240417232622067.png)

##### 12. 最小覆盖子串（76）

![image-20240418132540768](./hot100/image-20240418132540768.png)

![image-20240418140516756](./hot100/image-20240418140516756.png)

### 五、普通数组

##### 13. 最大子数组和（53）

![image-20240418141251656](./hot100/image-20240418141251656.png)

![image-20240418141644728](./hot100/image-20240418141644728.png)

##### 14. 合并区间（56）

![image-20240418141744176](./hot100/image-20240418141744176.png)

![image-20240418142003152](./hot100/image-20240418142003152.png)

##### 15. 轮转数组（189）

![image-20240418142111482](./hot100/image-20240418142111482.png)

![image-20240418143247190](./hot100/image-20240418143247190.png)

##### 16. 除自身以外数组的乘积

![image-20240418143403806](./hot100/image-20240418143403806.png)

![image-20240418145248200](./hot100/image-20240418145248200.png)

##### 17. 缺失的第一个正数（41）

![image-20240418151426146](./hot100/image-20240418151426146.png)

![image-20240418153026290](./hot100/image-20240418153026290.png)

### 六、矩阵

##### 18. 矩阵置零（73）

![image-20240419133804139](./hot100/image-20240419133804139.png)

![image-20240419143645935](./hot100/image-20240419143645935.png)

##### 19. 螺旋矩阵（54）

![image-20240425134742069](./hot100/image-20240425134742069.png)

![image-20240425140609092](./hot100/image-20240425140609092.png)

##### 20. 旋转图像（48）

![image-20240425140739579](./hot100/image-20240425140739579.png)

![image-20240425153039384](./hot100/image-20240425153039384.png)

##### 21. 搜索二维矩阵Ⅱ（240）

![image-20240425155113561](./hot100/image-20240425155113561.png)

![image-20240425194533916](./hot100/image-20240425194533916.png)

### 七、链表

##### 22. 相交链表（160）

![image-20240426141603173](./hot100/image-20240426141603173.png)

![image-20240426141636471](./hot100/image-20240426141636471.png)

##### 23. 反转链表（206）

![image-20240426142118823](./hot100/image-20240426142118823.png)

![image-20240426144131165](./hot100/image-20240426144131165.png)

##### 24. 回文链表（234）

![image-20240426144217298](./hot100/image-20240426144217298.png)

![image-20240426144811789](./hot100/image-20240426144811789.png)

##### 25. 环形链表（141）

![image-20240426144935957](./hot100/image-20240426144935957.png)

![image-20240426150241722](./hot100/image-20240426150241722.png)

##### 26. 环形链表Ⅱ（142）

![image-20240427102527535](./hot100/image-20240427102527535.png)

![image-20240427102506277](./hot100/image-20240427102506277.png)

##### 27. 合并两个有序链表（21）

![image-20240427103932755](./hot100/image-20240427103932755.png)

![image-20240427103918123](./hot100/image-20240427103918123.png)

##### 28. 两数相加（2）

![image-20240428133525192](./hot100/image-20240428133525192.png)

![image-20240428134308296](./hot100/image-20240428134308296.png)

##### 29. 删除链表的倒数第N个结点（19）

![image-20240428142243197](./hot100/image-20240428142243197.png)

![image-20240428143104122](./hot100/image-20240428143104122.png)

##### 30. 两两交换链表中的节点（24）

![image-20240428143213644](./hot100/image-20240428143213644.png)

![image-20240428150013587](./hot100/image-20240428150013587.png)

##### 31. K个一组翻转链表（25）

![image-20240428150335097](./hot100/image-20240428150335097.png)

![image-20240428155135495](./hot100/image-20240428155135495.png)

##### 32. 随机链表的复制（138）

![image-20240501112123727](./hot100/image-20240501112123727.png)

![image-20240501112202003](./hot100/image-20240501112202003.png)

##### 33. 排序链表（148）

![image-20240501112418113](./hot100/image-20240501112418113.png)

![image-20240502101642462](./hot100/image-20240502101642462.png)

##### 34. 合并K个升序链表（23）

![image-20240502105636908](./hot100/image-20240502105636908.png)

![image-20240502105601643](./hot100/image-20240502105601643.png)

##### 35. LRU缓存

### 八、二叉树

##### 36. 二叉树的中序遍历（94）

![image-20240503101103106](./hot100/image-20240503101103106.png)

![image-20240503101834065](./hot100/image-20240503101834065.png)

##### 37. 二叉树的最大深度（104）

![image-20240503102957926](./hot100/image-20240503102957926.png)

![image-20240503103022245](./hot100/image-20240503103022245.png)

##### 38. 翻转二叉树（226）

![image-20240503103542883](./hot100/image-20240503103542883.png)

![image-20240503103637608](./hot100/image-20240503103637608.png)

##### 39. 对称二叉树（101）

![image-20240503105147620](./hot100/image-20240503105147620.png)

![image-20240503105123410](./hot100/image-20240503105123410.png)

##### 40. 二叉树的直径（543）

![image-20240503111007886](./hot100/image-20240503111007886.png)

![image-20240503110954679](./hot100/image-20240503110954679.png)

##### 41. 二叉树的层序遍历（102）

![image-20240506181202573](./hot100/image-20240506181202573.png)

![image-20240506181451322](./hot100/image-20240506181451322.png)

##### 42. 将有序数组转化为二叉搜索树（108）

![image-20240506181735775](./hot100/image-20240506181735775.png)

![image-20240506181834771](./hot100/image-20240506181834771.png)

##### 43. 验证二叉搜索树（98）

![image-20240506182022671](./hot100/image-20240506182022671.png)

![image-20240506182226144](./hot100/image-20240506182226144.png)

##### 44. 二叉搜索树中的第K小的元素

![image-20240506182355916](./hot100/image-20240506182355916.png)

![image-20240506182454350](./hot100/image-20240506182454350.png)

##### 45. 二叉树的右视图（199）

![image-20240506182548134](./hot100/image-20240506182548134.png)

![image-20240506182651180](./hot100/image-20240506182651180.png)

##### 46. 二叉树展开为链表（114）

![image-20240508134516326](./hot100/image-20240508134516326.png)

![image-20240508134935512](./hot100/image-20240508134935512.png)

##### 47. 从前序与中序遍历序列构造二叉树（105）

![image-20240508134649702](./hot100/image-20240508134649702.png)

![image-20240508135541939](./hot100/image-20240508135541939.png)

##### 48. 路径总和Ⅲ（437）

![image-20240509142422567](./hot100/image-20240509142422567.png)

![image-20240509142314618](./hot100/image-20240509142314618.png)

##### 49. 二叉树的最近公共祖先（236）

![image-20240523134000330](./hot100/image-20240523134000330.png)

![image-20240523141251450](./hot100/image-20240523141251450.png)

第一种思路自己想的，第二种思路答案（pq只有三种情况，一pq分布在root左右返回root，二p=root，q在p的左右子树，三q=root，p在q的左右子树，代码需要理解一下）

##### 50. 二叉树中的最大路径和（124）

![image-20240714195633942](./hot100/image-20240714195633942.png)

![image-20240714200129804](./hot100/image-20240714200129804.png)

### 九、图论

##### 51. 岛屿数量（200）

![image-20240714200535073](./hot100/image-20240714200535073.png)

![image-20240714203319916](./hot100/image-20240714203319916.png)

##### 52. 腐烂的橘子（994）

![image-20240715161338843](./hot100/image-20240715161338843.png)

![image-20240715162015795](./hot100/image-20240715162015795.png)

##### 53. 课程表（207）

![image-20240715162145083](./hot100/image-20240715162145083.png)

![image-20240715162752203](./hot100/image-20240715162752203.png)

（自己写的太慢，主要思路是遇到1就递归，主要记拓扑排序的方法）

##### 54. 实现前缀树Trie（208）

![image-20240715163113430](./hot100/image-20240715163113430.png)

![image-20240715184740641](./hot100/image-20240715184740641.png)

### 十、回溯

##### 55. 全排列（46）

![image-20240715184932927](./hot100/image-20240715184932927.png)

![image-20240715185036879](./hot100/image-20240715185036879.png)

##### 56. 子集（78）

![image-20240715185124421](./hot100/image-20240715185124421.png)

![image-20240715185241500](./hot100/image-20240715185241500.png)

##### 57. 电话号码的数字组合（17）

![image-20240715185350126](./hot100/image-20240715185350126.png)

![image-20240715185558974](./hot100/image-20240715185558974.png)

##### 58. 组合总和（39）

![image-20240715185716242](./hot100/image-20240715185716242.png)

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        ans = []
        self.backtracking([], ans, target, 0, len(candidates), candidates)
        return ans
        
    def backtracking(self, path, ans, target, startIndex, length, candidates):
        if sum(path) > target: return
        if sum(path) == target:
            ans.append(path[:])
            return
        for i in range(startIndex, length):
            path.append(candidates[i])
            self.backtracking(path, ans, target, i, length, candidates)
            path.pop()
        return
```

##### 59. 括号生成（22）

![image-20240715190038773](./hot100/image-20240715190038773.png)

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        ans = []
        self.backtracking([], ans, n, 0, 0)
        return ans
    
    def backtracking(self, path, ans, n, left, right):
        if len(path) == n*2:
            ans.append(''.join(path))
            return
        # 左右相等，下一个只能左
        if left == right:
            path.append('(')
            self.backtracking(path, ans, n, left+1, right)
            path.pop()
        # 左大于右且左已满，下一个只能右
        elif left == n:
            path.append(')')
            self.backtracking(path, ans, n, left, right+1)
            path.pop()
        # 左大于右且左未满，下一个可左可右
        else:
            path.append('(')
            self.backtracking(path, ans, n, left+1, right)
            path.pop()
            path.append(')')
            self.backtracking(path, ans, n, left, right+1)
            path.pop()
        return
```

##### 60. 单词搜索（79）

![image-20240715190343061](./hot100/image-20240715190343061.png)

![image-20240715190406122](./hot100/image-20240715190406122.png)

```python
# class Solution:
#     def exist(self, board: List[List[str]], word: str) -> bool:
#         rows, cols = len(board), len(board[0])
#         for i in range(rows):
#             for j in range(cols):
#                 if board[i][j] == word[0]:
#                     visited = [[0 for _ in range(cols)] for _ in range(rows)]
#                     if self.backtracking('', word, visited, board, i, j, rows, cols): return True
#         return False
    

#     def backtracking(self, path, word, visited, board, i, j, rows, cols):
#         if i < 0 or j < 0 or i >= rows or j >= cols: return False
#         if len(path) < len(word) and board[i][j] == word[len(path)] and visited[i][j] == 0:
#             path += board[i][j]
#             if path == word: return True
#             visited[i][j] = 1
#             f1 = self.backtracking(path, word, visited, board, i+1, j, rows, cols)
#             f2 = self.backtracking(path, word, visited, board, i-1, j, rows, cols)
#             f3 = self.backtracking(path, word, visited, board, i, j+1, rows, cols)
#             f4 = self.backtracking(path, word, visited, board, i, j-1, rows, cols)
#             visited[i][j] = 0
#             path = path[:-1]
#             return f1 or f2 or f3 or f4
#         else:
#             return False


class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        def dfs(i, j, k):
            if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j] != word[k]: return False
            if k == len(word) - 1: return True
            # 直接等于空字符串，相当于visited==1已访问
            board[i][j] = ''
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
            board[i][j] = word[k]
            return res

        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(i, j, 0): return True
        return False
```

##### 61. 分割回文串（131）

![image-20240715190736605](./hot100/image-20240715190736605.png)

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        ans = []
        self.backtracking([], ans, 0, len(s), s)
        return ans
        
    def backtracking(self, path, ans, startIndex, length, s):
        if startIndex >= length:
            ans.append(path[:])
            return
        for i in range(startIndex+1, length+1):
            if s[startIndex: i] == s[startIndex: i][::-1]:
                path.append(s[startIndex: i])
                self.backtracking(path, ans, i, length, s)
                path.pop()
        return
```

##### 62. N皇后（51）

![image-20240715191050838](./hot100/image-20240715191050838.png)

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        cheeseBoard = ['.'*n for _ in range(n)]
        ans = []
        self.backtracking(cheeseBoard, 0, ans, n)
        return ans

    def backtracking(self, cheeseBoard, row, ans, n):
        if row == n:
            ans.append(cheeseBoard[:])
            return
        for i in range(n):
            if self.isValid(row, i, cheeseBoard, n):
                cheeseBoard[row] = cheeseBoard[row][:i] + 'Q' + cheeseBoard[row][i+1:]
                self.backtracking(cheeseBoard, row+1, ans, n)
                cheeseBoard[row] = cheeseBoard[row][:i] + '.' + cheeseBoard[row][i+1:]
        return
    
    def isValid(self, row, col, cheeseBoard, n):
        for i in range(row):
            if cheeseBoard[i][col] == 'Q': return False
        i, j = row - 1, col + 1
        while i >= 0 and j < n:
            if cheeseBoard[i][j] == 'Q': return False
            i -= 1
            j += 1
        i, j = row - 1, col - 1
        while i >= 0 and j >= 0:
            if cheeseBoard[i][j] == 'Q': return False
            i -= 1
            j -= 1
        return True
```

### 十一、二分查找

##### 63. 搜索插入位置（35）

![image-20240715191318026](./hot100/image-20240715191318026.png)

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target: return mid
            elif nums[mid] > target: right = mid - 1
            else: left = mid + 1
        return left
```

##### 64. 搜索二维矩阵（74）

![image-20240715191614365](./hot100/image-20240715191614365.png)

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        top, bottom = 0, len(matrix) - 1
        while top <= bottom:
            mid = (top + bottom) // 2
            if matrix[mid][0] > target: bottom = mid - 1
            else: top = mid + 1
        left, right = 0, len(matrix[0]) - 1
        while left <= right:
            mid = (left + right) // 2
            if matrix[bottom][mid] > target: right = mid - 1
            else: left = mid + 1
        return matrix[bottom][right] == target
```

##### 65. 在排序数组中查找元素的第一个和最后一个位置（34）

![image-20240715191749714](./hot100/image-20240715191749714.png)

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                ans_l, ans_r = mid, mid
                while ans_l > 0 and nums[ans_l-1] == nums[ans_l]: ans_l -= 1
                while ans_r < len(nums) - 1 and nums[ans_r] == nums[ans_r + 1]: ans_r += 1
                return [ans_l, ans_r]
            elif nums[mid] > target: right = mid - 1
            else: left = mid + 1
        return [-1, -1]
```

##### 66. 搜索旋转排序数组（33）

![image-20240716105604961](./hot100/image-20240716105604961.png)

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        # right是最小值所在点，调试一下就会发现
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < nums[right] < nums[left]: right = mid
            elif nums[mid] > nums[left] > nums[right]: left = mid
            else: break
        ans1 = self.binarySearch(nums, target, 0, right - 1)
        if ans1 != -1: return ans1
        ans2 = self.binarySearch(nums, target, right, len(nums)-1)
        return ans2 if ans2 != -1 else -1
    
    def binarySearch(self, nums, target, left, right):
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] > target: right = mid - 1
            else: left = mid + 1
        return right if nums[right] == target else -1
```

##### 67. 寻找旋转排序数组中的最小值（153）

![image-20240716105852432](./hot100/image-20240716105852432.png)

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            mid = (l + r) // 2
            if nums[mid] > nums[l] > nums[r]: l = mid
            elif nums[mid] < nums[r] < nums[l]: r = mid
            else: return nums[r] if nums[r] < nums[l] else nums[l]
```

##### 68. 寻找两个正序数组的中位数（4）

![image-20240716110135522](./hot100/image-20240716110135522.png)

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        n1, n2 = len(nums1), len(nums2)
        if n1 > n2: return self.findMedianSortedArrays(nums2, nums1)
        k = (n1 + n2 + 1) // 2
        l, r = 0, len(nums1)
        while l < r:
            m1 = (l + r) // 2
            m2 = k - m1
            # 至多有(m1 + m2 - 1) = (k - 1) 个元素比 nums1[m1] 小，所以 nums1[m1] 左侧排除
            if nums1[m1] < nums2[m2-1]: l = m1 + 1
            # 至少有(m1 + m2) = (k) 个元素比 nums1[m1] 小，所以 nums1[m1] 及其右侧排除
            else: r = m1
        m1 = l
        m2 = k - m1 
        c1 = max(nums1[m1-1] if m1 > 0 else float("-inf"), nums2[m2-1] if m2 > 0 else float("-inf") )
        if (n1 + n2) % 2 == 1:
            return c1
        c2 = min(nums1[m1] if m1 < n1 else float("inf"), nums2[m2] if m2 <n2 else float("inf"))
        return (c1 + c2) / 2
```

### 十二、栈

##### 69. 有效的括号（20）

![image-20240716110548859](./hot100/image-20240716110548859.png)

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for each in s:
            if each == '(' or each == '{' or each == '[':
                stack.append(each)
            else:
                if len(stack) == 0: return False
                left = stack.pop(-1)
                # 有一种括号的ord是91/93
                if abs(ord(each) - ord(left)) > 2: return False
        if len(stack) == 0: return True
        return False
```

##### 70. 最小栈（155）

![image-20240716110714991](./hot100/image-20240716110714991.png)

```python
class MinStack:

    def __init__(self):
        self.stack = []

    def push(self, val: int) -> None:
        if not self.stack:
            self.stack.append((val, val))
        else:
            self.stack.append((val, min(val, self.stack[-1][1])))

    def pop(self) -> None:
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1][0]

    def getMin(self) -> int:
        return self.stack[-1][1]



# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
```

##### 71. 字符串解码（394）

![image-20240716111211281](./hot100/image-20240716111211281.png)

```python
class Solution:
    def decodeString(self, s: str) -> str:
        ans = ''
        i, lens = 0, len(s)
        while i < lens:
            if abs(ord(s[i]) - ord('a')) <= 25: 
                ans += s[i]
                i += 1
            else: 
                path, end = self.decode(i, s, lens)
                ans += path
                i = end + 1
        return ans

    # decode从数字开始的一个组，可嵌套，即decode负责的是当前位置后的第一个[与其配对]之间的解构
    def decode(self, start, s, lens):
        i = start
        while s[i] != '[': i += 1
        times = int(s[start:i])
        j = i + 1
        chars = ''
        while j < lens:
            # 字母
            if (ord(s[j]) - ord('a')) >= 0 and (ord(s[j]) - ord('a')) <= 25: 
                chars += s[j]
                j += 1
            # 数字，嵌套
            elif (ord(s[j]) - ord('0')) >= 0 and (ord(s[j]) - ord('0')) <= 9:
                path, end = self.decode(j, s, lens)
                chars += path
                j = end + 1
            # ']'结束
            else:
                break
        path = times * chars
        return path, j 
```

##### 72. 每日温度（739）

![image-20240716111500680](./hot100/image-20240716111500680.png)

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        stack = []
        lens = len(temperatures)
        ans = [0] * lens
        for i in range(lens):
            # 栈非空且当前元素大于栈顶元素，出栈
            while len(stack) != 0 and temperatures[stack[-1]] < temperatures[i]:
                idx = stack.pop()
                ans[idx] = i - idx
            stack.append(i)
        return ans
```

##### 73. 柱状图中最大的矩形（84）

![image-20240727190852711](./hot100/image-20240727190852711.png)

```python
from typing import List


class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        size = len(heights)
        res = 0

        stack = []

        for i in range(size):
            while len(stack) > 0 and heights[i] < heights[stack[-1]]:
                cur_height = heights[stack.pop()]

                while len(stack) > 0 and cur_height == heights[stack[-1]]:
                    stack.pop()

                if len(stack) > 0:
                    cur_width = i - stack[-1] - 1
                else:
                    cur_width = i

                res = max(res, cur_height * cur_width)
            stack.append(i)

        while len(stack) > 0 is not None:
            cur_height = heights[stack.pop()]
            while len(stack) > 0 and cur_height == heights[stack[-1]]:
                stack.pop()

            if len(stack) > 0:
                cur_width = size - stack[-1] - 1
            else:
                cur_width = size
            res = max(res, cur_height * cur_width)

        return res
```

### 十三、堆

##### 74. 数组中的第K个最大元素（215）

![image-20240716121547293](./hot100/image-20240716121547293.png)

```python
# 默认小顶堆
import heapq as hp
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        pq = []
        for num in nums:
            hp.heappush(pq, num)
            # pop最小元素
            if len(pq) > k: hp.heappop(pq)
        return pq[0]
```

##### 75. 前K个高频元素（347）

![image-20240716121728304](./hot100/image-20240716121728304.png)

```python
import heapq as hp
from collections import defaultdict
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        pq, ans = [], []
        dic = defaultdict(int)
        for i in range(len(nums)):
            dic[nums[i]] += 1
        for each in dic:
            hp.heappush(pq, (-dic[each], each))
        for i in range(k):
            ans.append(hp.heappop(pq)[1])
        return ans
```

##### 76. 数据流的中位数（295）

![image-20240716121917664](./hot100/image-20240716121917664.png)

```python
import heapq as hp
class MedianFinder:

    def __init__(self):
        # arr1小顶堆保存较大的一半
        self.arr1 = []
        # arr2大顶堆保存较小的一半
        self.arr2 = []

    def addNum(self, num: int) -> None:
        # arr1多时先将num放入arr1并排出最小值，然后在放入arr2
        if len(self.arr1) != len(self.arr2):
            hp.heappush(self.arr1, num)
            hp.heappush(self.arr2, -hp.heappop(self.arr1))
        # 长度相等时先放入arr2并排出最大值，然后放入arr1
        else:
            hp.heappush(self.arr2, -num)
            hp.heappush(self.arr1, -hp.heappop(self.arr2))

    def findMedian(self) -> float:
        if len(self.arr1) != len(self.arr2): return float(self.arr1[0])
        return (self.arr1[0] - self.arr2[0]) / 2


# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder()
# obj.addNum(num)
# param_2 = obj.findMedian()
```

### 十四、贪心算法

##### 77. 买卖股票的最佳时机（121）

![image-20240716122113131](./hot100/image-20240716122113131.png)

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        cost, profit = float('inf'), 0
        for price in prices:
            cost = min(cost, price)
            profit = max(profit, price - cost)
        return profit
```

##### 78. 跳跃游戏（55）

![image-20240716122245408](./hot100/image-20240716122245408.png)

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        max_loc = 0
        for i in range(len(nums)):
            if max_loc < i: return False
            max_loc = max(i + nums[i], max_loc)
        return True
```

##### 79. 跳跃游戏Ⅱ（45）

![image-20240716122406855](./hot100/image-20240716122406855.png)

```python
# dp
# class Solution:
#     def jump(self, nums: List[int]) -> int:
#         dp = [float('inf')] * len(nums)
#         dp[0] = 0
#         for i in range(1, len(nums)):
#             for j in range(i):
#                 if i <= nums[j] + j:
#                     dp[i] = min(dp[i], dp[j] + 1)
#         return dp[-1]

# 贪心
class Solution:
    def jump(self, nums: List[int]) -> int:
        end, max_loc, ans = 0, 0, 0
        for i in range(len(nums)-1):
            max_loc = max(max_loc, nums[i] + i)
            # 到end前，所有的i到end都是一步之遥，不断更新max_loc，直到end，再更新ans和end
            if i == end:
                end = max_loc
                ans += 1
        return ans
```

##### 80. 划分字母区间（763）

![image-20240716122900479](./hot100/image-20240716122900479.png)

```python
from collections import defaultdict
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        dic = defaultdict(int)
        for i in range(len(s)):
            dic[s[i]] = i
        # far标识目前已遍历且尚未分割的最远位置
        far = dic[s[0]]
        # start标识当前未分割的起始位置
        start = 0
        ans = []
        for i in range(len(s)):
            # 当前字符的最远位置大于far更新far
            if dic[s[i]] > far:
                far = dic[s[i]]
            # 当前位置等于far说明可以分割
            if i == far:
                ans.append(i+1-start)
                start = i+1
        return ans
```

### 十五、动态规划

##### 81. 爬楼梯（70）

![image-20240716123025165](./hot100/image-20240716123025165.png)

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        pre1, pre2 = 2, 1
        if n <= 2: return n
        for i in range(2, n):
            ans = pre1 + pre2
            pre2, pre1 = pre1, ans
        return ans
```

##### 82. 杨辉三角（118）

![image-20240716123347048](./hot100/image-20240716123347048.png)

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows <= 2:
            return [[1]] if numRows == 1 else [[1], [1, 1]]
        ans = [[1], [1, 1]]
        for i in range(2, numRows):
            ans.append([1] + list(map(lambda x: x[0] + x[1], zip(ans[-1][:-1], ans[-1][1:]))) + [1])
        return ans
```

##### 83. 打家劫舍（198）

![image-20240716123455894](./hot100/image-20240716123455894.png)

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        pre, cur = 0 ,0
        for i in range(len(nums)):
            pre, cur = cur, max(cur, pre + nums[i])
        return cur
```

##### 84. 完全平方数（279）

![image-20240716123615495](./hot100/image-20240716123615495.png)

```python
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [float('inf') for i in range(n+1)]
        i = 1
        while i**2 <= n:
            dp[i**2] = 1
            i += 1
        for i in range(1, n+1):
            j = 1
            while j**2 <= i:
                dp[i] = min(dp[i], dp[i-j**2] + 1)
                j += 1
        return dp[-1]
```

##### 85. 零钱兑换（322）

![image-20240716123856685](./hot100/image-20240716123856685.png)

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        for i in range(1, amount+1):
            for coin in coins:
                if i >= coin:
                    dp[i] = min(dp[i], dp[i-coin]+1)
        return dp[-1] if dp[-1] != float('inf') else -1
```

##### 86. 单词拆分（139）

![image-20240716124058900](./hot100/image-20240716124058900.png)

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        dp = [False] * (len(s) + 1)
        dp[0] = True
        for i in range(1, len(s) + 1):
            for each in wordDict:
                if i >= len(each) and s[i-len(each):i] == each and dp[i-len(each)]:
                    dp[i] = True
        return dp[-1]
```

##### 87. 最长递增子序列（300）

![image-20240716124211283](./hot100/image-20240716124211283.png)

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [1] * len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

##### 88. 乘积最大子数组（152）

![image-20240716124343856](./hot100/image-20240716124343856.png)

```python
# dp[i][0]从头到当前位置乘积最大值，dp[i][1]从头到当前位置乘积最小值
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        dp = [[0, 0] for i in range(len(nums))]
        dp[0][0], dp[0][1] = nums[0], nums[0]
        for i in range(1, len(nums)):
            if nums[i] == 0: dp[i][0], dp[i][1] = 0, 0
            elif nums[i] > 0:
                if dp[i-1][1] > 0:
                    dp[i][1] = dp[i-1][1] * nums[i]
                else:
                    dp[i][1] = nums[i]
                if dp[i-1][0] <= 0:
                    dp[i][0] = dp[i-1][0] * nums[i]
                else:
                    dp[i][0] = nums[i]
            else:
                if dp[i-1][1] > 0:
                    dp[i][0] = dp[i-1][1] * nums[i]
                else:
                    dp[i][0] = nums[i]
                if dp[i-1][0] <= 0:
                    dp[i][1] = dp[i-1][0] * nums[i]
                else:
                    dp[i][1] = nums[i]
        return max([loc[1] for loc in dp])

# 更牛版本
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        imin, imax = 1, 1
        ans = float('-inf')
        for i in range(len(nums)):
            if nums[i] < 0:
                imin, imax = imax, imin
            imin = min(imin * nums[i], nums[i])
            imax = max(imax * nums[i], nums[i])
            ans = max(ans, imax)
        return ans
```

##### 89. 分割等和子集（416）

![image-20240716124626299](./hot100/image-20240716124626299.png)

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sums = sum(nums)
        if sums % 2 == 1: return False
        target = sums // 2
        dp = [0] * (target + 1)
        for each in nums:
            for j in range(target, each - 1, -1):
                dp[j] = max(dp[j - each] + each, dp[j])
        return dp[-1] == target
```

##### 90. 最长有效括号（32）

![image-20240725191649645](./hot100/image-20240725191649645.png)

```python
# 自己思路, dp[i][j]是一个[a, b], a是左边还需多少(, b是右边还需多少), 思路应该没问题, 超时
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        length = len(s)
        dp = [[[0, 0] for _ in range(length)] for _ in range(length)] 
        print(dp)
        max_len = 0
        for i in range(length-1, -1, -1):
            for j in range(i, length):
                if i == j: continue
                elif i + 1 == j:
                    if s[i] == '(' and s[j] == ')':
                        dp[i][j] = [0, 0]
                        max_len = max(max_len, 2)
                    elif s[i] == '(' and s[j] == '(':
                        dp[i][j] = [0, 2]
                    elif s[i] == ')' and s[j] == ')':
                        dp[i][j] = [2, 0]
                    else:
                        dp[i][j] = [1, 1]
                else:
                    if s[i] == '(':
                        # 左边缺左，补充左括号
                        if dp[i+1][j][0] > 0:
                            dp[i][j][0] = dp[i+1][j][0] - 1
                        # 左边不缺左，右边需更多右
                        else:
                            dp[i][j][1] = dp[i+1][j][1] + 1
                    elif s[i] == ')':
                        dp[i][j][0] = dp[i+1][j][0] + 1
                    if s[j] == '(':
                        dp[i][j][1] = dp[i][j-1][1] + 1
                    elif s[j] == ')':
                        # 右边缺右，补充右括号
                        if dp[i][j-1][1] > 0:
                            dp[i][j][1] = dp[i][j-1][1] - 1
                        # 右边不缺右，左边需更多左
                        else:
                            dp[i][j][0] = dp[i][j-1][0] + 1
                    if dp[i][j] == [0, 0]:
                        max_len = max(max_len, j - i + 1)
        return max_len

# 代码随想录
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        length = len(s)
        # dp[i]: 以i为结尾的最长匹配长度
        if length == 0: return 0
        dp = [0] * length
        for i in range(length):
            if s[i] == ')':
                # 找到当前还没匹配的第一个(
                pre = i - 1 - dp[i-1]
                if pre >= 0 and s[pre] == '(':
                    dp[i] = dp[i-1] + 2
                    # 这里注意, 存在()(()())这种情况, 最后一个)匹配到位置2的(后还需要判断一下pre-1因为有可能因为位置2的(卡住了, dp[3~6]都不会考虑dp[1]所以需要加一下
                    if pre > 0:
                        dp[i] += dp[pre-1]
        return max(dp)
```

### 十六、多维动态规划

##### 91. 不同路径（62）

![image-20240725192648887](./hot100/image-20240725192648887.png)

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[0] * n for _ in range(m)]
        dp[0][0] = 1
        for i in range(m):
            for j in range(n):
                if i >= 1:
                    dp[i][j] += dp[i-1][j]
                if j >= 1:
                    dp[i][j] += dp[i][j-1]
        return dp[-1][-1]
```

##### 92. 最小路径和（64）

![image-20240727094655476](./hot100/image-20240727094655476.png)

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [[0] * n for _ in range(m)]
        dp[0][0] = grid[0][0]
        for i in range(1, m):
            dp[i][0] = dp[i-1][0] + grid[i][0]
        for j in range(1, n):
            dp[0][j] = dp[0][j-1] + grid[0][j]

        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        return dp[-1][-1]
```

##### 93. 最长回文子串（5）

![image-20240727094906769](./hot100/image-20240727094906769.png)

```python
# 自己思路, dp[i][j]=1说明是回文, 每次是回文就动态更新l和r, dp[i][j]依赖于dp[i+1][j-1]所以i倒序更新
class Solution:
    def longestPalindrome(self, s: str) -> str:
        length = len(s)
        l, r, ans = 0, 0, 0
        dp = [[0] * length for _ in range(length)]
        for i in range(length-1, -1, -1):
            for j in range(i, length):
                if i == j:
                    dp[i][j] = 1
                elif i + 1 == j:
                    if s[i] == s[j]:
                        dp[i][j] = 1
                        if j-i+1 > ans:
                            ans = j-i+1
                            l, r = i, j
                elif dp[i+1][j-1] == 1 and s[i] == s[j]:
                    dp[i][j] = 1
                    if j-i+1 > ans:
                        ans = j-i+1
                        l, r = i, j
        return s[l:r+1]

# 中心扩散
class Solution:
    def longestPalindrome(self, s: str) -> str:
        l, r = 0, 0
        for i in range(len(s)):
            l1, r1 = self.diffusion(s, i, i)
            l2, r2 = self.diffusion(s, i, i+1)
            l, r = (l1, r1) if r1 - l1 > r - l else (l, r)
            l, r = (l2, r2) if r2 - l2 > r - l else (l, r)
        return s[l:r+1]

    
    def diffusion(self, s, l, r):
        while l >= 0 and r < len(s) and s[l] == s[r]:
            l -= 1
            r += 1
        return (l + 1, r - 1)
```

##### 94. 最长公共子序列（1143）

![image-20240727095524365](./hot100/image-20240727095524365.png)

```python
# 思路没问题, 代码略繁琐
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        length1, length2 = len(text1), len(text2)
        dp = [[0] * length2 for _ in range(length1)]
        dp[0][0] = 1 if text1[0] == text2[0] else 0
        for i in range(1, length1):
            dp[i][0] = 1 if text1[i] == text2[0] else dp[i-1][0]
        for j in range(1, length2):
            dp[0][j] = 1 if text1[0] == text2[j] else dp[0][j-1]
        for i in range(1, length1):
            for j in range(1, length2):
                if text1[i] == text2[j]:
                    dp[i][j] = max(dp[i][j], dp[i-1][j-1] + 1, dp[i-1][j], dp[i][j-1])
                else:
                    dp[i][j] = max(dp[i][j], dp[i-1][j], dp[i][j-1])
        return dp[-1][-1]

# 简洁代码
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        dp = [[0] * (len(text2) + 1) for _ in range(len(text1) + 1)]
        for i in range(1, len(text1) + 1):
            for j in range(1, len(text2) + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[-1][-1]
```

##### 95. 编辑距离（72）

![image-20240727100631102](./hot100/docker-compose.png)

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        wl1 = len(word1)
        wl2 = len(word2)
        dp = [[0] * (wl2 + 1) for _ in range(wl1 + 1)]
        for i in range(wl1 + 1):
            dp[i][0] = i
        for i in range(wl2 + 1):
            dp[0][i] = i
        for i in range(1, wl1 + 1):
            for j in range(1, wl2 + 1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
        return dp[-1][-1]
```

### 十七、技巧

##### 96. 只出现一次的数字（136）

![image-20240727103254628](./hot100/image-20240727103254628.png)

```python
# 位运算
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ans = 0
        for each in nums:
            ans ^= each
        return ans
```

##### 97. 多数元素（169）

![image-20240727105517605](./hot100/image-20240727105517605.png)

```python
# 摩尔投票，即记录一个票数，票数为0时当前元素作为众数，每遇到和众数不同的，就票数减1，因为存在推论
"""
推论一： 若记 众数 的票数为 +1 ，非众数 的票数为 −1 ，则一定有所有数字的 票数和 >0 。
推论二： 若数组的前 a 个数字的 票数和 =0 ，则 数组剩余 (n−a) 个数字的 票数和一定仍 >0 ，即后 (n−a) 个数字的 众数仍为 x 。

根据以上推论，记数组首个元素为 n1，众数为 x ，遍历并统计票数。当发生 票数和 =0 时，剩余数组的众数一定不变 ，这是由于：
当 n1 = x ： 抵消的所有数字中，有一半是众数 x 。
当 n1 != x ： 抵消的所有数字中，众数 x 的数量最少为 0 个，最多为一半。
利用此特性，每轮假设发生 票数和 =0 都可以 缩小剩余数组区间 。当遍历完成时，最后一轮假设的数字即为众数。
"""
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        tickets = 0
        for each in nums:
            if tickets == 0: most = each
            tickets += 1 if each == most else -1
        return most
```

##### 98. 颜色分类（75）

![image-20240727111159039](./hot100/image-20240727111159039.png)

```python
# 自己写法, 不算原地
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        nums_two, nums_zero = 0, 0
        for each in nums:
            if each == 2: nums_two += 1
            elif each == 0: nums_zero += 1
        for i in range(nums_zero):
            nums[i] = 0
        for i in range(len(nums)-nums_two-nums_zero):
            nums[i+nums_zero] = 1
        for i in range(nums_two):
            nums[len(nums)-1-i] = 2

# 双指针, 换0换2
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        l, r, i = 0, len(nums)-1, 0
        while i < len(nums):
            while i < r and nums[i] == 2:
                nums[r], nums[i] = nums[i], nums[r]
                r -= 1
            # 因为这么换过来，0～i-1位置已经排好了，三种情况，全0/全1/000111，这些情况均只需要换一次就可以再次实现顺序，所以不需要while，而上边换2就需要一直while
            if nums[i] == 0:
                nums[l], nums[i] = nums[i], nums[l]
                l += 1
            i += 1
```

##### 99. 下一个排列（31）

![image-20240727184957145](./hot100/image-20240727184957145.png)

```python
# 思路看下面链接, 主要是怎么去找那几个特殊位置的数字
"""
https://leetcode.cn/problems/next-permutation/solutions/80560/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/?envType=study-plan-v2&envId=top-100-liked

想要字典序变大，又不想尽可能小的大，所以需要从后边遍历，找到第一个nums[i]<nums[i+1]的i，这样[i+1, end]都是降序，然后让[start, i-1]不变，将[i+1, end]中大于nums[i]的最小数，记作nums[k]，ik位置互换，然后[i+1, end]升序即可
简单来说就是，找到最后一个向上的位置(nums[i]<nums[i+1])，然后把i后刚好大于它的数放到i位置，后边升序排列
"""
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        length = len(nums)
        start = -1
        for i in range(length-1, 0, -1):
            if nums[i-1] < nums[i]:
                start = i-1
                break
        if start == -1:
            for i in range(length // 2):
                nums[i], nums[length-1-i] = nums[length-1-i], nums[i]
        else:
            for i in range(length-1, start, -1):
                if nums[i] > nums[start]:
                    nums[i], nums[start] = nums[start], nums[i]
                    break
            for i in range(start+1, (length + start + 1) // 2):
                nums[i], nums[length+start-i] = nums[length+start-i], nums[i]
```

##### 100. 寻找重复数（287）

![image-20240727190538158](./hot100/image-20240727190538158.png)

```python
# 将数组看成一个链表，只需要找到链表的循环处即可（这思路太绝了）
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow, fast = 0, 0
        slow = nums[slow]
        fast = nums[nums[fast]]
        while slow != fast:
            slow = nums[slow]
            fast = nums[nums[fast]]
        pre1, pre2 = 0, slow
        while pre1 != pre2:
            pre1 = nums[pre1]
            pre2 = nums[pre2]
        return pre1
```

