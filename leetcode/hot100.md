# LeetCode 热题 100

### 一、哈希表

##### 1. 两数之和（1）

![image-20240411145506422](./hot100/image-20240411145506422.png)

![image-20240411145556999](./hot100/image-20240411145556999.png)

##### 2. 字母异位词（49）

![image-20240411145722760](./hot100/image-20240411145722760.png)

![image-20240411145834174](./hot100/image-20240411145834174.png)

##### 3. 最长连续序列（128）

![image-20240411150227500](./hot100/image-20240411150227500.png)

![image-20240411152315721](./hot100/image-20240411152315721.png)

### 二、双指针

##### 4. 移动零（283）

![image-20240412213054978](./hot100/image-20240412213054978.png)

![image-20240412213352144](./hot100/image-20240412213352144.png)

##### 5. 盛水最多的容器（11）

![image-20240412213627930](./hot100/image-20240412213627930.png)

![image-20240412214604625](./hot100/image-20240412214604625.png)

##### 6. 三数之和（15）

![image-20240412214844994](./hot100/image-20240412214844994.png)

![image-20240412222912790](./hot100/image-20240412222912790.png)

##### 7. 接雨水（42）

![image-20240413092435242](./hot100/image-20240413092435242.png)

![image-20240413095121792](./hot100/image-20240413095121792.png)

### 三、滑动窗口

##### 8. 无重复字符的最长子串（3）

![image-20240414101004121](./hot100/image-20240414101004121.png)

![image-20240414103031344](./hot100/image-20240414103031344.png)

##### 9. 找到字符串中所有字母异位词（438）

![image-20240416215002459](./hot100/image-20240416215002459.png)

![image-20240416220618087](./hot100/image-20240416220618087.png)

### 四、子串

##### 10. 和为K的子数组（560）

![image-20240416220723481](./hot100/image-20240416220723481.png)

![image-20240416224424748](./hot100/image-20240416224424748.png)

##### 11.  滑动窗口最大值（239）

![image-20240417224628015](./hot100/image-20240417224628015.png)

![image-20240417232622067](./hot100/image-20240417232622067.png)

##### 12. 最小覆盖子串（76）

![image-20240418132540768](./hot100/image-20240418132540768.png)

![image-20240418140516756](./hot100/image-20240418140516756.png)

### 五、普通数组

##### 13. 最大子数组和（53）

![image-20240418141251656](./hot100/image-20240418141251656.png)

![image-20240418141644728](./hot100/image-20240418141644728.png)

##### 14. 合并区间（56）

![image-20240418141744176](./hot100/image-20240418141744176.png)

![image-20240418142003152](./hot100/image-20240418142003152.png)

##### 15. 轮转数组（189）

![image-20240418142111482](./hot100/image-20240418142111482.png)

![image-20240418143247190](./hot100/image-20240418143247190.png)

##### 16. 除自身以外数组的乘积

![image-20240418143403806](./hot100/image-20240418143403806.png)

![image-20240418145248200](./hot100/image-20240418145248200.png)

##### 17. 缺失的第一个正数（41）

![image-20240418151426146](./hot100/image-20240418151426146.png)

![image-20240418153026290](./hot100/image-20240418153026290.png)

### 六、矩阵

##### 18. 矩阵置零（73）

![image-20240419133804139](./hot100/image-20240419133804139.png)

![image-20240419143645935](./hot100/image-20240419143645935.png)

##### 19. 螺旋矩阵（54）

![image-20240425134742069](./hot100/image-20240425134742069.png)

![image-20240425140609092](./hot100/image-20240425140609092.png)

##### 20. 旋转图像（48）

![image-20240425140739579](./hot100/image-20240425140739579.png)

![image-20240425153039384](./hot100/image-20240425153039384.png)

##### 21. 搜索二维矩阵Ⅱ（240）

![image-20240425155113561](./hot100/image-20240425155113561.png)

![image-20240425194533916](./hot100/image-20240425194533916.png)

### 七、链表

##### 22. 相交链表（160）

![image-20240426141603173](./hot100/image-20240426141603173.png)

![image-20240426141636471](./hot100/image-20240426141636471.png)

##### 23. 反转链表（206）

![image-20240426142118823](./hot100/image-20240426142118823.png)

![image-20240426144131165](./hot100/image-20240426144131165.png)

##### 24. 回文链表（234）

![image-20240426144217298](./hot100/image-20240426144217298.png)

![image-20240426144811789](./hot100/image-20240426144811789.png)

##### 25. 环形链表（141）

![image-20240426144935957](./hot100/image-20240426144935957.png)

![image-20240426150241722](./hot100/image-20240426150241722.png)

##### 26. 环形链表Ⅱ（142）

![image-20240427102527535](./hot100/image-20240427102527535.png)

![image-20240427102506277](./hot100/image-20240427102506277.png)

##### 27. 合并两个有序链表（21）

![image-20240427103932755](./hot100/image-20240427103932755.png)

![image-20240427103918123](./hot100/image-20240427103918123.png)

##### 28. 两数相加（2）

![image-20240428133525192](./hot100/image-20240428133525192.png)

![image-20240428134308296](./hot100/image-20240428134308296.png)

##### 29. 删除链表的倒数第N个结点（19）

![image-20240428142243197](./hot100/image-20240428142243197.png)

![image-20240428143104122](./hot100/image-20240428143104122.png)

##### 30. 两两交换链表中的节点（24）

![image-20240428143213644](./hot100/image-20240428143213644.png)

![image-20240428150013587](./hot100/image-20240428150013587.png)

##### 31. K个一组翻转链表（25）

![image-20240428150335097](./hot100/image-20240428150335097.png)

![image-20240428155135495](./hot100/image-20240428155135495.png)

##### 32. 随机链表的复制（138）

![image-20240501112123727](./hot100/image-20240501112123727.png)

![image-20240501112202003](./hot100/image-20240501112202003.png)

##### 33. 排序链表（148）

![image-20240501112418113](./hot100/image-20240501112418113.png)

![image-20240502101642462](./hot100/image-20240502101642462.png)

##### 34. 合并K个升序链表（23）

![image-20240502105636908](./hot100/image-20240502105636908.png)

![image-20240502105601643](./hot100/image-20240502105601643.png)

##### 35. LRU缓存

### 八、二叉树

##### 36. 二叉树的中序遍历（94）

![image-20240503101103106](./hot100/image-20240503101103106.png)

![image-20240503101834065](./hot100/image-20240503101834065.png)

##### 37. 二叉树的最大深度（104）

![image-20240503102957926](./hot100/image-20240503102957926.png)

![image-20240503103022245](./hot100/image-20240503103022245.png)

##### 38. 翻转二叉树（226）

![image-20240503103542883](./hot100/image-20240503103542883.png)

![image-20240503103637608](./hot100/image-20240503103637608.png)

##### 39. 对称二叉树（101）

![image-20240503105147620](./hot100/image-20240503105147620.png)

![image-20240503105123410](./hot100/image-20240503105123410.png)

##### 40. 二叉树的直径（543）

![image-20240503111007886](./hot100/image-20240503111007886.png)

![image-20240503110954679](./hot100/image-20240503110954679.png)

##### 41. 二叉树的层序遍历（102）

![image-20240506181202573](./hot100/image-20240506181202573.png)

![image-20240506181451322](./hot100/image-20240506181451322.png)

##### 42. 将有序数组转化为二叉搜索树（108）

![image-20240506181735775](./hot100/image-20240506181735775.png)

![image-20240506181834771](./hot100/image-20240506181834771.png)

##### 43. 验证二叉搜索树（98）

![image-20240506182022671](./hot100/image-20240506182022671.png)

![image-20240506182226144](./hot100/image-20240506182226144.png)

##### 44. 二叉搜索树中的第K小的元素

![image-20240506182355916](./hot100/image-20240506182355916.png)

![image-20240506182454350](./hot100/image-20240506182454350.png)

##### 45. 二叉树的右视图（199）

![image-20240506182548134](./hot100/image-20240506182548134.png)

![image-20240506182651180](./hot100/image-20240506182651180.png)

##### 46. 二叉树展开为链表（114）

![image-20240508134516326](./hot100/image-20240508134516326.png)

![image-20240508134935512](./hot100/image-20240508134935512.png)

##### 47. 从前序与中序遍历序列构造二叉树（105）

![image-20240508134649702](./hot100/image-20240508134649702.png)

![image-20240508135541939](./hot100/image-20240508135541939.png)

##### 48. 路径总和Ⅲ（437）

![image-20240509142422567](./hot100/image-20240509142422567.png)

![image-20240509142314618](./hot100/image-20240509142314618.png)

##### 49. 二叉树的最近公共祖先（236）

![image-20240523134000330](./hot100/image-20240523134000330.png)

![image-20240523141251450](./hot100/image-20240523141251450.png)

第一种思路自己想的，第二种思路答案（pq只有三种情况，一pq分布在root左右返回root，二p=root，q在p的左右子树，三q=root，p在q的左右子树，代码需要理解一下）

##### 50. 二叉树中的最大路径和（124）

![image-20240714195633942](./hot100/image-20240714195633942.png)

![image-20240714200129804](./hot100/image-20240714200129804.png)

### 九、图论

##### 51. 岛屿数量（200）

![image-20240714200535073](./hot100/image-20240714200535073.png)

![image-20240714203319916](./hot100/image-20240714203319916.png)

##### 52. 腐烂的橘子（994）

![image-20240715161338843](./hot100/image-20240715161338843.png)

![image-20240715162015795](./hot100/image-20240715162015795.png)

##### 53. 课程表（207）

![image-20240715162145083](./hot100/image-20240715162145083.png)

![image-20240715162752203](./hot100/image-20240715162752203.png)

（自己写的太慢，主要思路是遇到1就递归，主要记拓扑排序的方法）

##### 54. 实现前缀树Trie（208）

![image-20240715163113430](./hot100/image-20240715163113430.png)

![image-20240715184740641](./hot100/image-20240715184740641.png)

### 十、回溯

##### 55. 全排列（46）

![image-20240715184932927](./hot100/image-20240715184932927.png)

![image-20240715185036879](./hot100/image-20240715185036879.png)

##### 56. 子集（78）

![image-20240715185124421](./hot100/image-20240715185124421.png)

![image-20240715185241500](./hot100/image-20240715185241500.png)

##### 57. 电话号码的数字组合（17）

![image-20240715185350126](./hot100/image-20240715185350126.png)

![image-20240715185558974](./hot100/image-20240715185558974.png)

##### 58. 组合总和（39）

![image-20240715185716242](./hot100/image-20240715185716242.png)

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        ans = []
        self.backtracking([], ans, target, 0, len(candidates), candidates)
        return ans
        
    def backtracking(self, path, ans, target, startIndex, length, candidates):
        if sum(path) > target: return
        if sum(path) == target:
            ans.append(path[:])
            return
        for i in range(startIndex, length):
            path.append(candidates[i])
            self.backtracking(path, ans, target, i, length, candidates)
            path.pop()
        return
```

##### 59. 括号生成（22）

![image-20240715190038773](./hot100/image-20240715190038773.png)

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        ans = []
        self.backtracking([], ans, n, 0, 0)
        return ans
    
    def backtracking(self, path, ans, n, left, right):
        if len(path) == n*2:
            ans.append(''.join(path))
            return
        # 左右相等，下一个只能左
        if left == right:
            path.append('(')
            self.backtracking(path, ans, n, left+1, right)
            path.pop()
        # 左大于右且左已满，下一个只能右
        elif left == n:
            path.append(')')
            self.backtracking(path, ans, n, left, right+1)
            path.pop()
        # 左大于右且左未满，下一个可左可右
        else:
            path.append('(')
            self.backtracking(path, ans, n, left+1, right)
            path.pop()
            path.append(')')
            self.backtracking(path, ans, n, left, right+1)
            path.pop()
        return
```

##### 60. 单词搜索（79）

![image-20240715190343061](./hot100/image-20240715190343061.png)

![image-20240715190406122](./hot100/image-20240715190406122.png)

```python
# class Solution:
#     def exist(self, board: List[List[str]], word: str) -> bool:
#         rows, cols = len(board), len(board[0])
#         for i in range(rows):
#             for j in range(cols):
#                 if board[i][j] == word[0]:
#                     visited = [[0 for _ in range(cols)] for _ in range(rows)]
#                     if self.backtracking('', word, visited, board, i, j, rows, cols): return True
#         return False
    

#     def backtracking(self, path, word, visited, board, i, j, rows, cols):
#         if i < 0 or j < 0 or i >= rows or j >= cols: return False
#         if len(path) < len(word) and board[i][j] == word[len(path)] and visited[i][j] == 0:
#             path += board[i][j]
#             if path == word: return True
#             visited[i][j] = 1
#             f1 = self.backtracking(path, word, visited, board, i+1, j, rows, cols)
#             f2 = self.backtracking(path, word, visited, board, i-1, j, rows, cols)
#             f3 = self.backtracking(path, word, visited, board, i, j+1, rows, cols)
#             f4 = self.backtracking(path, word, visited, board, i, j-1, rows, cols)
#             visited[i][j] = 0
#             path = path[:-1]
#             return f1 or f2 or f3 or f4
#         else:
#             return False


class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        def dfs(i, j, k):
            if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j] != word[k]: return False
            if k == len(word) - 1: return True
            # 直接等于空字符串，相当于visited==1已访问
            board[i][j] = ''
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
            board[i][j] = word[k]
            return res

        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(i, j, 0): return True
        return False
```

##### 61. 分割回文串（131）

![image-20240715190736605](./hot100/image-20240715190736605.png)

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        ans = []
        self.backtracking([], ans, 0, len(s), s)
        return ans
        
    def backtracking(self, path, ans, startIndex, length, s):
        if startIndex >= length:
            ans.append(path[:])
            return
        for i in range(startIndex+1, length+1):
            if s[startIndex: i] == s[startIndex: i][::-1]:
                path.append(s[startIndex: i])
                self.backtracking(path, ans, i, length, s)
                path.pop()
        return
```

##### 62. N皇后（51）

![image-20240715191050838](./hot100/image-20240715191050838.png)

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        cheeseBoard = ['.'*n for _ in range(n)]
        ans = []
        self.backtracking(cheeseBoard, 0, ans, n)
        return ans

    def backtracking(self, cheeseBoard, row, ans, n):
        if row == n:
            ans.append(cheeseBoard[:])
            return
        for i in range(n):
            if self.isValid(row, i, cheeseBoard, n):
                cheeseBoard[row] = cheeseBoard[row][:i] + 'Q' + cheeseBoard[row][i+1:]
                self.backtracking(cheeseBoard, row+1, ans, n)
                cheeseBoard[row] = cheeseBoard[row][:i] + '.' + cheeseBoard[row][i+1:]
        return
    
    def isValid(self, row, col, cheeseBoard, n):
        for i in range(row):
            if cheeseBoard[i][col] == 'Q': return False
        i, j = row - 1, col + 1
        while i >= 0 and j < n:
            if cheeseBoard[i][j] == 'Q': return False
            i -= 1
            j += 1
        i, j = row - 1, col - 1
        while i >= 0 and j >= 0:
            if cheeseBoard[i][j] == 'Q': return False
            i -= 1
            j -= 1
        return True
```

### 十一、二分查找

##### 63. 搜索插入位置（35）

![image-20240715191318026](./hot100/image-20240715191318026.png)

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target: return mid
            elif nums[mid] > target: right = mid - 1
            else: left = mid + 1
        return left
```

##### 64. 搜索二维矩阵（74）

![image-20240715191614365](./hot100/image-20240715191614365.png)

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        top, bottom = 0, len(matrix) - 1
        while top <= bottom:
            mid = (top + bottom) // 2
            if matrix[mid][0] > target: bottom = mid - 1
            else: top = mid + 1
        left, right = 0, len(matrix[0]) - 1
        while left <= right:
            mid = (left + right) // 2
            if matrix[bottom][mid] > target: right = mid - 1
            else: left = mid + 1
        return matrix[bottom][right] == target
```

##### 65. 在排序数组中查找元素的第一个和最后一个位置（34）

![image-20240715191749714](./hot100/image-20240715191749714.png)

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                ans_l, ans_r = mid, mid
                while ans_l > 0 and nums[ans_l-1] == nums[ans_l]: ans_l -= 1
                while ans_r < len(nums) - 1 and nums[ans_r] == nums[ans_r + 1]: ans_r += 1
                return [ans_l, ans_r]
            elif nums[mid] > target: right = mid - 1
            else: left = mid + 1
        return [-1, -1]
```

##### 66. 搜索旋转排序数组（33）

![image-20240716105604961](./hot100/image-20240716105604961.png)

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        # right是最小值所在点，调试一下就会发现
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < nums[right] < nums[left]: right = mid
            elif nums[mid] > nums[left] > nums[right]: left = mid
            else: break
        ans1 = self.binarySearch(nums, target, 0, right - 1)
        if ans1 != -1: return ans1
        ans2 = self.binarySearch(nums, target, right, len(nums)-1)
        return ans2 if ans2 != -1 else -1
    
    def binarySearch(self, nums, target, left, right):
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] > target: right = mid - 1
            else: left = mid + 1
        return right if nums[right] == target else -1
```

##### 67. 寻找旋转排序数组中的最小值（153）

![image-20240716105852432](./hot100/image-20240716105852432.png)

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            mid = (l + r) // 2
            if nums[mid] > nums[l] > nums[r]: l = mid
            elif nums[mid] < nums[r] < nums[l]: r = mid
            else: return nums[r] if nums[r] < nums[l] else nums[l]
```

##### 68. 寻找两个正序数组的中位数（4）

![image-20240716110135522](./hot100/image-20240716110135522.png)

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        n1, n2 = len(nums1), len(nums2)
        if n1 > n2: return self.findMedianSortedArrays(nums2, nums1)
        k = (n1 + n2 + 1) // 2
        l, r = 0, len(nums1)
        while l < r:
            m1 = (l + r) // 2
            m2 = k - m1
            # 至多有(m1 + m2 - 1) = (k - 1) 个元素比 nums1[m1] 小，所以 nums1[m1] 左侧排除
            if nums1[m1] < nums2[m2-1]: l = m1 + 1
            # 至少有(m1 + m2) = (k) 个元素比 nums1[m1] 小，所以 nums1[m1] 及其右侧排除
            else: r = m1
        m1 = l
        m2 = k - m1 
        c1 = max(nums1[m1-1] if m1 > 0 else float("-inf"), nums2[m2-1] if m2 > 0 else float("-inf") )
        if (n1 + n2) % 2 == 1:
            return c1
        c2 = min(nums1[m1] if m1 < n1 else float("inf"), nums2[m2] if m2 <n2 else float("inf"))
        return (c1 + c2) / 2
```

### 十二、栈

##### 69. 有效的括号（20）

![image-20240716110548859](./hot100/image-20240716110548859.png)

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for each in s:
            if each == '(' or each == '{' or each == '[':
                stack.append(each)
            else:
                if len(stack) == 0: return False
                left = stack.pop(-1)
                # 有一种括号的ord是91/93
                if abs(ord(each) - ord(left)) > 2: return False
        if len(stack) == 0: return True
        return False
```

##### 70. 最小栈（155）

![image-20240716110714991](./hot100/image-20240716110714991.png)

```python
class MinStack:

    def __init__(self):
        self.stack = []

    def push(self, val: int) -> None:
        if not self.stack:
            self.stack.append((val, val))
        else:
            self.stack.append((val, min(val, self.stack[-1][1])))

    def pop(self) -> None:
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1][0]

    def getMin(self) -> int:
        return self.stack[-1][1]



# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
```

##### 71. 字符串解码（394）

![image-20240716111211281](./hot100/image-20240716111211281.png)

```python
class Solution:
    def decodeString(self, s: str) -> str:
        ans = ''
        i, lens = 0, len(s)
        while i < lens:
            if abs(ord(s[i]) - ord('a')) <= 25: 
                ans += s[i]
                i += 1
            else: 
                path, end = self.decode(i, s, lens)
                ans += path
                i = end + 1
        return ans

    # decode从数字开始的一个组，可嵌套，即decode负责的是当前位置后的第一个[与其配对]之间的解构
    def decode(self, start, s, lens):
        i = start
        while s[i] != '[': i += 1
        times = int(s[start:i])
        j = i + 1
        chars = ''
        while j < lens:
            # 字母
            if (ord(s[j]) - ord('a')) >= 0 and (ord(s[j]) - ord('a')) <= 25: 
                chars += s[j]
                j += 1
            # 数字，嵌套
            elif (ord(s[j]) - ord('0')) >= 0 and (ord(s[j]) - ord('0')) <= 9:
                path, end = self.decode(j, s, lens)
                chars += path
                j = end + 1
            # ']'结束
            else:
                break
        path = times * chars
        return path, j 
```

##### 72. 每日温度（739）

![image-20240716111500680](./hot100/image-20240716111500680.png)

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        stack = []
        lens = len(temperatures)
        ans = [0] * lens
        for i in range(lens):
            # 栈非空且当前元素大于栈顶元素，出栈
            while len(stack) != 0 and temperatures[stack[-1]] < temperatures[i]:
                idx = stack.pop()
                ans[idx] = i - idx
            stack.append(i)
        return ans
```

##### 73. 柱状图中最大的矩形（84）

![image-20240716111857973](/Users/loujianyue/Desktop/TricksHub/leetcode/hot100/image-20240716111857973.png)

```python

```

### 十三、堆

##### 74. 数组中的第K个最大元素（215）

![image-20240716121547293](./hot100/image-20240716121547293.png)

```python
# 默认小顶堆
import heapq as hp
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        pq = []
        for num in nums:
            hp.heappush(pq, num)
            # pop最小元素
            if len(pq) > k: hp.heappop(pq)
        return pq[0]
```

##### 75. 前K个高频元素（347）

![image-20240716121728304](./hot100/image-20240716121728304.png)

```python
import heapq as hp
from collections import defaultdict
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        pq, ans = [], []
        dic = defaultdict(int)
        for i in range(len(nums)):
            dic[nums[i]] += 1
        for each in dic:
            hp.heappush(pq, (-dic[each], each))
        for i in range(k):
            ans.append(hp.heappop(pq)[1])
        return ans
```

##### 76. 数据流的中位数（295）

![image-20240716121917664](./hot100/image-20240716121917664.png)

```python
import heapq as hp
class MedianFinder:

    def __init__(self):
        # arr1小顶堆保存较大的一半
        self.arr1 = []
        # arr2大顶堆保存较小的一半
        self.arr2 = []

    def addNum(self, num: int) -> None:
        # arr1多时先将num放入arr1并排出最小值，然后在放入arr2
        if len(self.arr1) != len(self.arr2):
            hp.heappush(self.arr1, num)
            hp.heappush(self.arr2, -hp.heappop(self.arr1))
        # 长度相等时先放入arr2并排出最大值，然后放入arr1
        else:
            hp.heappush(self.arr2, -num)
            hp.heappush(self.arr1, -hp.heappop(self.arr2))

    def findMedian(self) -> float:
        if len(self.arr1) != len(self.arr2): return float(self.arr1[0])
        return (self.arr1[0] - self.arr2[0]) / 2


# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder()
# obj.addNum(num)
# param_2 = obj.findMedian()
```

### 十四、贪心算法

##### 77. 买卖股票的最佳时机（121）

![image-20240716122113131](./hot100/image-20240716122113131.png)

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        cost, profit = float('inf'), 0
        for price in prices:
            cost = min(cost, price)
            profit = max(profit, price - cost)
        return profit
```

##### 78. 跳跃游戏（55）

![image-20240716122245408](./hot100/image-20240716122245408.png)

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        max_loc = 0
        for i in range(len(nums)):
            if max_loc < i: return False
            max_loc = max(i + nums[i], max_loc)
        return True
```

##### 79. 跳跃游戏Ⅱ（45）

![image-20240716122406855](./hot100/image-20240716122406855.png)

```python
# dp
# class Solution:
#     def jump(self, nums: List[int]) -> int:
#         dp = [float('inf')] * len(nums)
#         dp[0] = 0
#         for i in range(1, len(nums)):
#             for j in range(i):
#                 if i <= nums[j] + j:
#                     dp[i] = min(dp[i], dp[j] + 1)
#         return dp[-1]

# 贪心
class Solution:
    def jump(self, nums: List[int]) -> int:
        end, max_loc, ans = 0, 0, 0
        for i in range(len(nums)-1):
            max_loc = max(max_loc, nums[i] + i)
            # 到end前，所有的i到end都是一步之遥，不断更新max_loc，直到end，再更新ans和end
            if i == end:
                end = max_loc
                ans += 1
        return ans
```

##### 80. 划分字母区间（763）

![image-20240716122900479](./hot100/image-20240716122900479.png)

```python
from collections import defaultdict
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        dic = defaultdict(int)
        for i in range(len(s)):
            dic[s[i]] = i
        # far标识目前已遍历且尚未分割的最远位置
        far = dic[s[0]]
        # start标识当前未分割的起始位置
        start = 0
        ans = []
        for i in range(len(s)):
            # 当前字符的最远位置大于far更新far
            if dic[s[i]] > far:
                far = dic[s[i]]
            # 当前位置等于far说明可以分割
            if i == far:
                ans.append(i+1-start)
                start = i+1
        return ans
```

### 十五、动态规划

##### 81. 爬楼梯（70）

![image-20240716123025165](./hot100/image-20240716123025165.png)

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        pre1, pre2 = 2, 1
        if n <= 2: return n
        for i in range(2, n):
            ans = pre1 + pre2
            pre2, pre1 = pre1, ans
        return ans
```

##### 82. 杨辉三角（118）

![image-20240716123347048](./hot100/image-20240716123347048.png)

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows <= 2:
            return [[1]] if numRows == 1 else [[1], [1, 1]]
        ans = [[1], [1, 1]]
        for i in range(2, numRows):
            ans.append([1] + list(map(lambda x: x[0] + x[1], zip(ans[-1][:-1], ans[-1][1:]))) + [1])
        return ans
```

##### 83. 打家劫舍（198）

![image-20240716123455894](./hot100/image-20240716123455894.png)

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        pre, cur = 0 ,0
        for i in range(len(nums)):
            pre, cur = cur, max(cur, pre + nums[i])
        return cur
```

##### 84. 完全平方数（279）

![image-20240716123615495](./hot100/image-20240716123615495.png)

```python
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [float('inf') for i in range(n+1)]
        i = 1
        while i**2 <= n:
            dp[i**2] = 1
            i += 1
        for i in range(1, n+1):
            j = 1
            while j**2 <= i:
                dp[i] = min(dp[i], dp[i-j**2] + 1)
                j += 1
        return dp[-1]
```

##### 85. 零钱兑换（322）

![image-20240716123856685](./hot100/image-20240716123856685.png)

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        for i in range(1, amount+1):
            for coin in coins:
                if i >= coin:
                    dp[i] = min(dp[i], dp[i-coin]+1)
        return dp[-1] if dp[-1] != float('inf') else -1
```

##### 86. 单词拆分（139）

![image-20240716124058900](./hot100/image-20240716124058900.png)

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        dp = [False] * (len(s) + 1)
        dp[0] = True
        for i in range(1, len(s) + 1):
            for each in wordDict:
                if i >= len(each) and s[i-len(each):i] == each and dp[i-len(each)]:
                    dp[i] = True
        return dp[-1]
```

##### 87. 最长递增子序列（300）

![image-20240716124211283](./hot100/image-20240716124211283.png)

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [1] * len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

##### 88. 乘积最大子数组（152）

![image-20240716124343856](./hot100/image-20240716124343856.png)

```python
# dp[i][0]从头到当前位置乘积最大值，dp[i][1]从头到当前位置乘积最小值
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        dp = [[0, 0] for i in range(len(nums))]
        dp[0][0], dp[0][1] = nums[0], nums[0]
        for i in range(1, len(nums)):
            if nums[i] == 0: dp[i][0], dp[i][1] = 0, 0
            elif nums[i] > 0:
                if dp[i-1][1] > 0:
                    dp[i][1] = dp[i-1][1] * nums[i]
                else:
                    dp[i][1] = nums[i]
                if dp[i-1][0] <= 0:
                    dp[i][0] = dp[i-1][0] * nums[i]
                else:
                    dp[i][0] = nums[i]
            else:
                if dp[i-1][1] > 0:
                    dp[i][0] = dp[i-1][1] * nums[i]
                else:
                    dp[i][0] = nums[i]
                if dp[i-1][0] <= 0:
                    dp[i][1] = dp[i-1][0] * nums[i]
                else:
                    dp[i][1] = nums[i]
        return max([loc[1] for loc in dp])

# 更牛版本
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        imin, imax = 1, 1
        ans = float('-inf')
        for i in range(len(nums)):
            if nums[i] < 0:
                imin, imax = imax, imin
            imin = min(imin * nums[i], nums[i])
            imax = max(imax * nums[i], nums[i])
            ans = max(ans, imax)
        return ans
```

##### 89. 分割等和子集（416）

![image-20240716124626299](./hot100/image-20240716124626299.png)

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sums = sum(nums)
        if sums % 2 == 1: return False
        target = sums // 2
        dp = [0] * (target + 1)
        for each in nums:
            for j in range(target, each - 1, -1):
                dp[j] = max(dp[j - each] + each, dp[j])
        return dp[-1] == target
```

